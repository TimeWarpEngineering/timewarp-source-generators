namespace TimeWarp.SourceGenerators;

using System.Collections.Immutable;

[Generator]
public class InterfaceDelegationGenerator : IIncrementalGenerator
{
  private static readonly DiagnosticDescriptor ClassNotPartialDescriptor = new(
      id: "TW1001",
      title: "Class must be partial for interface delegation",
      messageFormat: "Class '{0}' must be marked as partial to use [Implements] attribute",
      category: "InterfaceDelegation",
      DiagnosticSeverity.Error,
      isEnabledByDefault: true
  );

  private static readonly DiagnosticDescriptor InterfaceNotImplementedDescriptor = new(
      id: "TW1002",
      title: "Class does not implement the delegated interface",
      messageFormat: "Class '{0}' must implement interface '{1}' to delegate to field/property '{2}'",
      category: "InterfaceDelegation",
      DiagnosticSeverity.Error,
      isEnabledByDefault: true
  );

  private static readonly DiagnosticDescriptor DuplicateDelegationDescriptor = new(
      id: "TW1003",
      title: "Multiple fields delegate the same interface",
      messageFormat: "Interface '{0}' is delegated by multiple fields/properties in class '{1}'",
      category: "InterfaceDelegation",
      DiagnosticSeverity.Error,
      isEnabledByDefault: true
  );

  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    // Generate the ImplementsAttribute source code
    context.RegisterPostInitializationOutput(ctx =>
    {
      string attributeSource = @"// <auto-generated/>
#nullable enable

namespace TimeWarp.SourceGenerators
{
    /// <summary>
    /// Marks a field or property as the implementation delegate for an interface.
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Field | System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
    internal class ImplementsAttribute : System.Attribute
    {
    }
}
";
      ctx.AddSource("ImplementsAttribute.g.cs", SourceText.From(attributeSource, Encoding.UTF8));
    });

    // Find all fields and properties marked with [Implements] attribute
    IncrementalValuesProvider<(MemberDeclarationSyntax?, ClassDeclarationSyntax?, SemanticModel?)> implementsMembers =
        context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (node, _) => IsMemberWithAttribute(node),
                transform: (ctx, _) =>
                {
                  var member = (MemberDeclarationSyntax)ctx.Node;

                  // Check if any symbol from this member has the ImplementsAttribute
                  var symbolsToCheck = new List<ISymbol>();
                  if (member is FieldDeclarationSyntax fieldDecl)
                  {
                    // For fields, check each variable declarator
                    foreach (VariableDeclaratorSyntax variable in fieldDecl.Declaration.Variables)
                    {
                      ISymbol? symbol = ctx.SemanticModel.GetDeclaredSymbol(variable);
                      if (symbol != null) symbolsToCheck.Add(symbol);
                    }
                  }
                  else
                  {
                    ISymbol? symbol = ctx.SemanticModel.GetDeclaredSymbol(member);
                    if (symbol != null) symbolsToCheck.Add(symbol);
                  }

                  // Check if any of these symbols have the ImplementsAttribute
                  bool hasImplementsAttribute = symbolsToCheck.Any(s =>
                        s.GetAttributes().Any(ad =>
                            ad.AttributeClass?.Name == "ImplementsAttribute" ||
                            ad.AttributeClass?.Name == "Implements"));

                  if (!hasImplementsAttribute)
                    return ((MemberDeclarationSyntax?)null, (ClassDeclarationSyntax?)null, (SemanticModel?)null);

                  ClassDeclarationSyntax classDeclaration = member.Ancestors().OfType<ClassDeclarationSyntax>().FirstOrDefault();
                  return (member, classDeclaration, ctx.SemanticModel);
                })
            .Where(tuple => tuple.Item1 != null && tuple.Item2 != null);

    // Generate delegation code for each class
    context.RegisterSourceOutput(implementsMembers.Collect(), (sourceContext, members) =>
    {
      // Group by class
      IEnumerable<IGrouping<ClassDeclarationSyntax?, (MemberDeclarationSyntax?, ClassDeclarationSyntax?, SemanticModel?)>> groupedByClass = members.GroupBy(m => m.Item2);

      foreach (IGrouping<ClassDeclarationSyntax?, (MemberDeclarationSyntax?, ClassDeclarationSyntax?, SemanticModel?)>? classGroup in groupedByClass)
      {
        ClassDeclarationSyntax classDeclaration = classGroup.Key!;
        string className = classDeclaration.Identifier.Text;

        // Check if class is partial
        if (!classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
        {
          sourceContext.ReportDiagnostic(
                  Diagnostic.Create(
                      ClassNotPartialDescriptor,
                      classDeclaration.Identifier.GetLocation(),
                      className
                  )
              );
          continue;
        }

        // Get semantic model (use first member's semantic model)
        SemanticModel semanticModel = classGroup.First().Item3!;
        INamedTypeSymbol? classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
        if (classSymbol == null) continue;

        // Get namespace
        BaseNamespaceDeclarationSyntax namespaceDecl = classDeclaration.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
        string? namespaceName = namespaceDecl?.Name.ToString();

        // Process each [Implements] member
        var delegations = new List<(string MemberName, ITypeSymbol InterfaceType, List<string> GeneratedCode)>();
        var seenInterfaces = new HashSet<string>();

        foreach ((MemberDeclarationSyntax?, ClassDeclarationSyntax?, SemanticModel?) item in classGroup)
        {
          MemberDeclarationSyntax member = item.Item1!;
          // Get the symbols for this member (fields may have multiple variables)
          var memberSymbols = new List<ISymbol>();
          if (member is FieldDeclarationSyntax fieldDecl)
          {
            foreach (VariableDeclaratorSyntax variable in fieldDecl.Declaration.Variables)
            {
              ISymbol? symbol = semanticModel.GetDeclaredSymbol(variable);
              if (symbol != null) memberSymbols.Add(symbol);
            }
          }
          else
          {
            ISymbol? symbol = semanticModel.GetDeclaredSymbol(member);
            if (symbol != null) memberSymbols.Add(symbol);
          }

          foreach (ISymbol memberSymbol in memberSymbols)
          {
            // Check if this specific symbol has the ImplementsAttribute
            bool hasImplementsAttr = memberSymbol.GetAttributes().Any(ad =>
                        ad.AttributeClass?.Name == "ImplementsAttribute" ||
                        ad.AttributeClass?.Name == "Implements");

            if (!hasImplementsAttr) continue;

            string memberName = memberSymbol.Name;
            ITypeSymbol? memberType = memberSymbol switch
            {
              IFieldSymbol field => field.Type,
              IPropertySymbol property => property.Type,
              _ => null
            };

            if (memberType == null) continue;

            // Check if the member type is an interface
            if (memberType.TypeKind != TypeKind.Interface)
            {
              // Could be a class that implements an interface - find matching interface
              ImmutableArray<INamedTypeSymbol> implementedInterfaces = memberType.AllInterfaces;
              INamedTypeSymbol? matchingInterface = implementedInterfaces.FirstOrDefault(i =>
                        classSymbol.AllInterfaces.Any(ci => SymbolEqualityComparer.Default.Equals(ci, i)));

              if (matchingInterface != null)
                memberType = matchingInterface;
              else
                continue;
            }

            ITypeSymbol interfaceType = memberType;
            string interfaceFullName = interfaceType.ToDisplayString();

            // Check if class implements this interface
            bool implementsInterface = classSymbol.AllInterfaces.Any(i =>
                    SymbolEqualityComparer.Default.Equals(i, interfaceType));

            if (!implementsInterface)
            {
              sourceContext.ReportDiagnostic(
                      Diagnostic.Create(
                          InterfaceNotImplementedDescriptor,
                          member.GetLocation(),
                          className,
                          interfaceFullName,
                          memberName
                      )
                  );
              continue;
            }

            // Check for duplicate delegations
            if (!seenInterfaces.Add(interfaceFullName))
            {
              sourceContext.ReportDiagnostic(
                      Diagnostic.Create(
                          DuplicateDelegationDescriptor,
                          member.GetLocation(),
                          interfaceFullName,
                          className
                      )
                  );
              continue;
            }

            // Generate delegation code for this interface
            List<string> generatedCode = GenerateInterfaceDelegation(
                    interfaceType,
                    memberName,
                    classSymbol,
                    semanticModel
                );

            delegations.Add((memberName, interfaceType, generatedCode));
          }
        }

        // Generate the source file
        if (delegations.Any())
        {
          string sourceCode = GenerateSourceFile(
                    className,
                    namespaceName,
                    delegations
                );

          sourceContext.AddSource(
                  $"{className}.implements.g.cs",
                  SourceText.From(sourceCode, Encoding.UTF8)
              );
        }
      }
    });
  }

  private static bool IsMemberWithAttribute(SyntaxNode node)
  {
    if (node is not MemberDeclarationSyntax member)
      return false;

    if (member is not FieldDeclarationSyntax && member is not PropertyDeclarationSyntax)
      return false;

    // Check if it has any attributes
    return member.AttributeLists.Count > 0;
  }

  private static List<string> GenerateInterfaceDelegation(
      ITypeSymbol interfaceType,
      string delegateMemberName,
      INamedTypeSymbol classSymbol,
      SemanticModel semanticModel)
  {
    var code = new List<string>();
    var processedMembers = new HashSet<string>();

    // Process the interface and all inherited interfaces
    if (interfaceType is INamedTypeSymbol namedInterface)
    {
      ProcessInterfaceMembers(namedInterface, delegateMemberName, classSymbol, code, processedMembers);
    }

    return code;
  }

  private static void ProcessInterfaceMembers(
      INamedTypeSymbol interfaceType,
      string delegateMemberName,
      INamedTypeSymbol classSymbol,
      List<string> code,
      HashSet<string> processedMembers)
  {
    // First, recursively process all base interfaces
    foreach (INamedTypeSymbol baseInterface in interfaceType.AllInterfaces)
    {
      ProcessInterfaceMembersCore(baseInterface, delegateMemberName, classSymbol, code, processedMembers);
    }

    // Then process the current interface's own members
    ProcessInterfaceMembersCore(interfaceType, delegateMemberName, classSymbol, code, processedMembers);
  }

  private static void ProcessInterfaceMembersCore(
      INamedTypeSymbol interfaceType,
      string delegateMemberName,
      INamedTypeSymbol classSymbol,
      List<string> code,
      HashSet<string> processedMembers)
  {
    ImmutableArray<ISymbol> interfaceMembers = interfaceType.GetMembers();

    foreach (ISymbol member in interfaceMembers)
    {
      // Create a unique key for this member to avoid duplicates
      string memberKey = $"{member.Name}_{member.Kind}";
      if (member is IMethodSymbol method)
      {
        // Include return type and parameter types in key to handle overloads and different return types
        string returnType = method.ReturnType.ToDisplayString();
        string paramTypes = string.Join(",", method.Parameters.Select(p => p.Type.ToDisplayString()));
        memberKey = $"{member.Name}_{method.MethodKind}_{returnType}_{paramTypes}";
      }

      // Skip if we've already processed this member
      if (!processedMembers.Add(memberKey))
        continue;

      // Skip if the class already implements this member explicitly
      ISymbol? existingImplementation = classSymbol.GetMembers(member.Name)
                .FirstOrDefault(m => !m.IsImplicitlyDeclared);

      if (existingImplementation != null)
        continue; // Allow manual override

      switch (member)
      {
        case IMethodSymbol methodSymbol when methodSymbol.MethodKind == MethodKind.Ordinary:
          code.Add(GenerateMethodDelegation(methodSymbol, delegateMemberName));
          break;

        case IPropertySymbol property:
          code.Add(GeneratePropertyDelegation(property, delegateMemberName));
          break;

        case IEventSymbol eventSymbol:
          code.Add(GenerateEventDelegation(eventSymbol, delegateMemberName));
          break;
      }
    }
  }

  private static string GenerateMethodDelegation(IMethodSymbol method, string delegateMemberName)
  {
    string returnType = method.ReturnType.ToDisplayString();
    string methodName = method.Name;
    string parameters = string.Join(", ", method.Parameters.Select(p =>
            $"{p.Type.ToDisplayString()} {p.Name}"));
    string arguments = string.Join(", ", method.Parameters.Select(p => p.Name));

    string returnKeyword = method.ReturnsVoid ? "" : "return ";

    return $@"    public {returnType} {methodName}({parameters})
    {{
        {returnKeyword}{delegateMemberName}.{methodName}({arguments});
    }}";
  }

  private static string GeneratePropertyDelegation(IPropertySymbol property, string delegateMemberName)
  {
    string propertyType = property.Type.ToDisplayString();
    string propertyName = property.Name;

    // Check if this is an indexer
    if (property.IsIndexer)
    {
      string parameters = string.Join(", ", property.Parameters.Select(p =>
              $"{p.Type.ToDisplayString()} {p.Name}"));
      string arguments = string.Join(", ", property.Parameters.Select(p => p.Name));

      string getter = property.GetMethod != null ? $" get => {delegateMemberName}[{arguments}];" : "";
      string setter = property.SetMethod != null ? $" set => {delegateMemberName}[{arguments}] = value;" : "";

      return $@"    public {propertyType} this[{parameters}]
    {{
{getter}{setter}
    }}";
    }

    // Regular property
    string regularGetter = property.GetMethod != null ? $" get => {delegateMemberName}.{propertyName};" : "";
    string regularSetter = property.SetMethod != null ? $" set => {delegateMemberName}.{propertyName} = value;" : "";

    return $@"    public {propertyType} {propertyName}
    {{
{regularGetter}{regularSetter}
    }}";
  }

  private static string GenerateEventDelegation(IEventSymbol eventSymbol, string delegateMemberName)
  {
    string eventType = eventSymbol.Type.ToDisplayString();
    string eventName = eventSymbol.Name;

    return $@"    public event {eventType} {eventName}
    {{
        add => {delegateMemberName}.{eventName} += value;
        remove => {delegateMemberName}.{eventName} -= value;
    }}";
  }

  private static string GenerateSourceFile(
      string className,
      string? namespaceName,
      List<(string MemberName, ITypeSymbol InterfaceType, List<string> GeneratedCode)> delegations)
  {
    var builder = new StringBuilder();

    builder.AppendLine("// <auto-generated/>");
    builder.AppendLine("#nullable enable");
    builder.AppendLine();

    if (!string.IsNullOrEmpty(namespaceName))
    {
      builder.AppendLine($"namespace {namespaceName};");
      builder.AppendLine();
    }

    builder.AppendLine($"// Interface delegation for {className} - YO YO YO MAMA v2 with inherited interfaces!");
    builder.AppendLine($"public partial class {className}");
    builder.AppendLine("{");

    foreach ((string? memberName, ITypeSymbol? interfaceType, List<string>? generatedCode) in delegations)
    {
      builder.AppendLine($"    // Delegation to {memberName} for {interfaceType.ToDisplayString()}");
      foreach (string code in generatedCode)
      {
        builder.AppendLine(code);
        builder.AppendLine();
      }
    }

    builder.AppendLine("}");

    return builder.ToString();
  }
}
