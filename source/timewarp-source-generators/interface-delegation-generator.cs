namespace TimeWarp.SourceGenerators;

[Generator]
public class InterfaceDelegationGenerator : IIncrementalGenerator
{
    private static readonly DiagnosticDescriptor ClassNotPartialDescriptor = new(
        id: "TW1001",
        title: "Class must be partial for interface delegation",
        messageFormat: "Class '{0}' must be marked as partial to use [Implements] attribute",
        category: "InterfaceDelegation",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor InterfaceNotImplementedDescriptor = new(
        id: "TW1002",
        title: "Class does not implement the delegated interface",
        messageFormat: "Class '{0}' must implement interface '{1}' to delegate to field/property '{2}'",
        category: "InterfaceDelegation",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    private static readonly DiagnosticDescriptor DuplicateDelegationDescriptor = new(
        id: "TW1003",
        title: "Multiple fields delegate the same interface",
        messageFormat: "Interface '{0}' is delegated by multiple fields/properties in class '{1}'",
        category: "InterfaceDelegation",
        DiagnosticSeverity.Error,
        isEnabledByDefault: true
    );

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Generate the ImplementsAttribute source code
        context.RegisterPostInitializationOutput(ctx =>
        {
            var attributeSource = @"// <auto-generated/>
#nullable enable

namespace TimeWarp.SourceGenerators
{
    /// <summary>
    /// Marks a field or property as the implementation delegate for an interface.
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Field | System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
    internal class ImplementsAttribute : System.Attribute
    {
    }
}
";
            ctx.AddSource("ImplementsAttribute.g.cs", SourceText.From(attributeSource, Encoding.UTF8));
        });

        // Find all fields and properties marked with [Implements] attribute
        IncrementalValuesProvider<(MemberDeclarationSyntax?, ClassDeclarationSyntax?, SemanticModel?)> implementsMembers =
            context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: (node, _) => IsMemberWithAttribute(node),
                    transform: (ctx, _) =>
                    {
                        var member = (MemberDeclarationSyntax)ctx.Node;

                        // Check if any symbol from this member has the ImplementsAttribute
                        var symbolsToCheck = new List<ISymbol>();
                        if (member is FieldDeclarationSyntax fieldDecl)
                        {
                            // For fields, check each variable declarator
                            foreach (var variable in fieldDecl.Declaration.Variables)
                            {
                                var symbol = ctx.SemanticModel.GetDeclaredSymbol(variable);
                                if (symbol != null) symbolsToCheck.Add(symbol);
                            }
                        }
                        else
                        {
                            var symbol = ctx.SemanticModel.GetDeclaredSymbol(member);
                            if (symbol != null) symbolsToCheck.Add(symbol);
                        }

                        // Check if any of these symbols have the ImplementsAttribute
                        var hasImplementsAttribute = symbolsToCheck.Any(s =>
                            s.GetAttributes().Any(ad =>
                                ad.AttributeClass?.Name == "ImplementsAttribute" ||
                                ad.AttributeClass?.Name == "Implements"));

                        if (!hasImplementsAttribute)
                            return ((MemberDeclarationSyntax?)null, (ClassDeclarationSyntax?)null, (SemanticModel?)null);

                        var classDeclaration = member.Ancestors().OfType<ClassDeclarationSyntax>().FirstOrDefault();
                        return (member, classDeclaration, ctx.SemanticModel);
                    })
                .Where(tuple => tuple.Item1 != null && tuple.Item2 != null);

        // Generate delegation code for each class
        context.RegisterSourceOutput(implementsMembers.Collect(), (sourceContext, members) =>
        {
            // Group by class
            var groupedByClass = members.GroupBy(m => m.Item2);

            foreach (var classGroup in groupedByClass)
            {
                var classDeclaration = classGroup.Key!;
                var className = classDeclaration.Identifier.Text;

                // Check if class is partial
                if (!classDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
                {
                    sourceContext.ReportDiagnostic(
                        Diagnostic.Create(
                            ClassNotPartialDescriptor,
                            classDeclaration.Identifier.GetLocation(),
                            className
                        )
                    );
                    continue;
                }

                // Get semantic model (use first member's semantic model)
                var semanticModel = classGroup.First().Item3!;
                var classSymbol = semanticModel.GetDeclaredSymbol(classDeclaration);
                if (classSymbol == null) continue;

                // Get namespace
                var namespaceDecl = classDeclaration.Ancestors().OfType<BaseNamespaceDeclarationSyntax>().FirstOrDefault();
                var namespaceName = namespaceDecl?.Name.ToString();

                // Process each [Implements] member
                var delegations = new List<(string MemberName, ITypeSymbol InterfaceType, List<string> GeneratedCode)>();
                var seenInterfaces = new HashSet<string>();

                foreach (var item in classGroup)
                {
                    var member = item.Item1!;
                    // Get the symbols for this member (fields may have multiple variables)
                    var memberSymbols = new List<ISymbol>();
                    if (member is FieldDeclarationSyntax fieldDecl)
                    {
                        foreach (var variable in fieldDecl.Declaration.Variables)
                        {
                            var symbol = semanticModel.GetDeclaredSymbol(variable);
                            if (symbol != null) memberSymbols.Add(symbol);
                        }
                    }
                    else
                    {
                        var symbol = semanticModel.GetDeclaredSymbol(member);
                        if (symbol != null) memberSymbols.Add(symbol);
                    }

                    foreach (var memberSymbol in memberSymbols)
                    {
                        // Check if this specific symbol has the ImplementsAttribute
                        var hasImplementsAttr = memberSymbol.GetAttributes().Any(ad =>
                            ad.AttributeClass?.Name == "ImplementsAttribute" ||
                            ad.AttributeClass?.Name == "Implements");

                        if (!hasImplementsAttr) continue;

                        var memberName = memberSymbol.Name;
                        var memberType = memberSymbol switch
                        {
                            IFieldSymbol field => field.Type,
                            IPropertySymbol property => property.Type,
                            _ => null
                        };

                        if (memberType == null) continue;

                    // Check if the member type is an interface
                    if (memberType.TypeKind != TypeKind.Interface)
                    {
                        // Could be a class that implements an interface - find matching interface
                        var implementedInterfaces = memberType.AllInterfaces;
                        var matchingInterface = implementedInterfaces.FirstOrDefault(i =>
                            classSymbol.AllInterfaces.Any(ci => SymbolEqualityComparer.Default.Equals(ci, i)));

                        if (matchingInterface != null)
                            memberType = matchingInterface;
                        else
                            continue;
                    }

                    var interfaceType = memberType;
                    var interfaceFullName = interfaceType.ToDisplayString();

                    // Check if class implements this interface
                    var implementsInterface = classSymbol.AllInterfaces.Any(i =>
                        SymbolEqualityComparer.Default.Equals(i, interfaceType));

                    if (!implementsInterface)
                    {
                        sourceContext.ReportDiagnostic(
                            Diagnostic.Create(
                                InterfaceNotImplementedDescriptor,
                                member.GetLocation(),
                                className,
                                interfaceFullName,
                                memberName
                            )
                        );
                        continue;
                    }

                    // Check for duplicate delegations
                    if (!seenInterfaces.Add(interfaceFullName))
                    {
                        sourceContext.ReportDiagnostic(
                            Diagnostic.Create(
                                DuplicateDelegationDescriptor,
                                member.GetLocation(),
                                interfaceFullName,
                                className
                            )
                        );
                        continue;
                    }

                    // Generate delegation code for this interface
                    var generatedCode = GenerateInterfaceDelegation(
                        interfaceType,
                        memberName,
                        classSymbol,
                        semanticModel
                    );

                    delegations.Add((memberName, interfaceType, generatedCode));
                    }
                }

                // Generate the source file
                if (delegations.Any())
                {
                    var sourceCode = GenerateSourceFile(
                        className,
                        namespaceName,
                        delegations
                    );

                    sourceContext.AddSource(
                        $"{className}.implements.g.cs",
                        SourceText.From(sourceCode, Encoding.UTF8)
                    );
                }
            }
        });
    }

    private static bool IsMemberWithAttribute(SyntaxNode node)
    {
        if (node is not MemberDeclarationSyntax member)
            return false;

        if (member is not FieldDeclarationSyntax && member is not PropertyDeclarationSyntax)
            return false;

        // Check if it has any attributes
        return member.AttributeLists.Count > 0;
    }

    private static List<string> GenerateInterfaceDelegation(
        ITypeSymbol interfaceType,
        string delegateMemberName,
        INamedTypeSymbol classSymbol,
        SemanticModel semanticModel)
    {
        var code = new List<string>();

        // Get all members of the interface
        var interfaceMembers = interfaceType.GetMembers();

        foreach (var member in interfaceMembers)
        {
            // Skip if the class already implements this member explicitly
            var existingImplementation = classSymbol.GetMembers(member.Name)
                .FirstOrDefault(m => !m.IsImplicitlyDeclared);

            if (existingImplementation != null)
                continue; // Allow manual override

            switch (member)
            {
                case IMethodSymbol method when method.MethodKind == MethodKind.Ordinary:
                    code.Add(GenerateMethodDelegation(method, delegateMemberName));
                    break;

                case IPropertySymbol property:
                    code.Add(GeneratePropertyDelegation(property, delegateMemberName));
                    break;

                case IEventSymbol eventSymbol:
                    code.Add(GenerateEventDelegation(eventSymbol, delegateMemberName));
                    break;
            }
        }

        return code;
    }

    private static string GenerateMethodDelegation(IMethodSymbol method, string delegateMemberName)
    {
        var returnType = method.ReturnType.ToDisplayString();
        var methodName = method.Name;
        var parameters = string.Join(", ", method.Parameters.Select(p =>
            $"{p.Type.ToDisplayString()} {p.Name}"));
        var arguments = string.Join(", ", method.Parameters.Select(p => p.Name));

        var returnKeyword = method.ReturnsVoid ? "" : "return ";

        return $@"    public {returnType} {methodName}({parameters})
    {{
        {returnKeyword}{delegateMemberName}.{methodName}({arguments});
    }}";
    }

    private static string GeneratePropertyDelegation(IPropertySymbol property, string delegateMemberName)
    {
        var propertyType = property.Type.ToDisplayString();
        var propertyName = property.Name;

        var getter = property.GetMethod != null ? $" get => {delegateMemberName}.{propertyName};" : "";
        var setter = property.SetMethod != null ? $" set => {delegateMemberName}.{propertyName} = value;" : "";

        return $@"    public {propertyType} {propertyName}
    {{
{getter}{setter}
    }}";
    }

    private static string GenerateEventDelegation(IEventSymbol eventSymbol, string delegateMemberName)
    {
        var eventType = eventSymbol.Type.ToDisplayString();
        var eventName = eventSymbol.Name;

        return $@"    public event {eventType} {eventName}
    {{
        add => {delegateMemberName}.{eventName} += value;
        remove => {delegateMemberName}.{eventName} -= value;
    }}";
    }

    private static string GenerateSourceFile(
        string className,
        string? namespaceName,
        List<(string MemberName, ITypeSymbol InterfaceType, List<string> GeneratedCode)> delegations)
    {
        var builder = new StringBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine("#nullable enable");
        builder.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            builder.AppendLine($"namespace {namespaceName};");
            builder.AppendLine();
        }

        builder.AppendLine($"// Interface delegation for {className}");
        builder.AppendLine($"public partial class {className}");
        builder.AppendLine("{");

        foreach (var (memberName, interfaceType, generatedCode) in delegations)
        {
            builder.AppendLine($"    // Delegation to {memberName} for {interfaceType.ToDisplayString()}");
            foreach (var code in generatedCode)
            {
                builder.AppendLine(code);
                builder.AppendLine();
            }
        }

        builder.AppendLine("}");

        return builder.ToString();
    }
}
