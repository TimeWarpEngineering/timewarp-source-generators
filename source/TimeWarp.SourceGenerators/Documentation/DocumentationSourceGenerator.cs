using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Text.RegularExpressions;

namespace TimeWarp.SourceGenerators;

[Generator]
public class DocumentationSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required for now
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Get all .cs.md files from AdditionalFiles
        var markdownFiles = context.AdditionalFiles
            .Where(f => f.Path.EndsWith(".cs.md"))
            .ToDictionary(
                f => f.Path.Substring(0, f.Path.Length - 3), // Remove .md to get .cs path
                f => f.GetText()?.ToString() ?? string.Empty
            );

        // Find all .cs files in the compilation
        var csFiles = context.Compilation.SyntaxTrees
            .Where(st => st.FilePath.EndsWith(".cs"))
            .Select(st => st.FilePath);

        foreach (var csFile in csFiles)
        {
            // Check if we have corresponding markdown documentation
            if (markdownFiles.TryGetValue(csFile, out var mdContent))
            {
                var documentationContent = GenerateDocumentation(mdContent, Path.GetFileNameWithoutExtension(csFile));
                
                // Generate the documentation file
                var documentationFileName = Path.GetFileNameWithoutExtension(csFile) + ".Documentation.cs";

                context.AddSource
                (
                    documentationFileName,
                    SourceText.From(documentationContent, Encoding.UTF8)
                );
            }
        }
    }

    private string GenerateDocumentation(string markdownContent, string className)
    {
        var documentation = new StringBuilder();
        documentation.AppendLine("// <auto-generated/>");
        documentation.AppendLine("#nullable enable");
        documentation.AppendLine();
        
        // Extract namespace from class documentation if it exists, otherwise use default
        var namespaceMatch = Regex.Match(markdownContent, @"namespace\s+([\w.]+)");
        var namespaceName = namespaceMatch.Success ? 
            namespaceMatch.Groups[1].Value : 
            "TimeWarp.SourceGenerators.Documentation";
            
        documentation.AppendLine($"namespace {namespaceName};");
        documentation.AppendLine();

        // Split content into sections
        var sections = markdownContent.Split(new[] { "\r\n\r\n", "\n\n" }, StringSplitOptions.RemoveEmptyEntries);
        
        // Process class documentation
        var classSection = sections.First();
        documentation.AppendLine("/// <summary>");
        documentation.AppendLine($"/// {classSection.Split('\n').Last().Trim()}");
        documentation.AppendLine("/// </summary>");
        documentation.AppendLine($"public partial class {className}");
        documentation.AppendLine("{");

        // Process method documentation
        var methodSections = sections.Where(s => s.StartsWith("### ")).ToList();
        foreach (var methodSection in methodSections)
        {
            var lines = methodSection.Split('\n');
            var methodName = lines[0].TrimStart('#', ' ');
            
            documentation.AppendLine("    /// <summary>");
            
            // Add method description
            var descriptionLines = lines.Skip(1)
                .TakeWhile(l => !l.Trim().StartsWith("Parameters:") && !l.Trim().StartsWith("Returns:"))
                .Where(l => !string.IsNullOrWhiteSpace(l));
                
            foreach (var line in descriptionLines)
            {
                documentation.AppendLine($"    /// {line.Trim()}");
            }
            documentation.AppendLine("    /// </summary>");

            // Add parameters
            var parametersSection = lines.SkipWhile(l => !l.Trim().StartsWith("Parameters:"))
                .TakeWhile(l => !l.Trim().StartsWith("Returns:"))
                .Skip(1) // Skip "Parameters:" line
                .Where(l => !string.IsNullOrWhiteSpace(l));

            foreach (var param in parametersSection)
            {
                var paramMatch = Regex.Match(param.Trim(), @"-\s*(\w+):\s*(.+)");
                if (paramMatch.Success)
                {
                    documentation.AppendLine($"    /// <param name=\"{paramMatch.Groups[1].Value.Trim()}\">{paramMatch.Groups[2].Value.Trim()}</param>");
                }
            }

            // Add return value
            var returnsLine = lines.FirstOrDefault(l => l.Trim().StartsWith("Returns:"));
            if (returnsLine != null)
            {
                var returnDescription = returnsLine.Substring("Returns:".Length).Trim();
                documentation.AppendLine($"    /// <returns>{returnDescription}</returns>");
            }

            documentation.AppendLine();
        }

        documentation.AppendLine("}");

        return documentation.ToString();
    }
}
