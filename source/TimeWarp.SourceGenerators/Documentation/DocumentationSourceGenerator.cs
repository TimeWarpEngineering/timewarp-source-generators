using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Text;
using System.Text.RegularExpressions;

namespace TimeWarp.SourceGenerators;

[Generator]
public class DocumentationSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register additional files with .cs.md extension
        IncrementalValuesProvider<AdditionalText> markdownFiles = context.AdditionalTextsProvider
            .Where(file => file.Path.EndsWith(".cs.md", StringComparison.OrdinalIgnoreCase));

        // Get all C# source files
        IncrementalValuesProvider<SyntaxTree> sourceFiles = context.CompilationProvider
            .SelectMany((compilation, _) => compilation.SyntaxTrees)
            .Where(tree => tree.FilePath.EndsWith(".cs", StringComparison.OrdinalIgnoreCase));

        // Combine markdown files with their corresponding source files
        IncrementalValuesProvider<(AdditionalText MarkdownFile, SyntaxTree SourceFile)> combined = 
            markdownFiles.Combine(sourceFiles)
            .Where(tuple => 
                Path.GetFileNameWithoutExtension(tuple.Left.Path) == 
                Path.GetFileNameWithoutExtension(tuple.Right.FilePath));

        // Generate documentation
        context.RegisterSourceOutput(combined, (context, tuple) =>
        {
            var (markdownFile, sourceFile) = tuple;
            var mdContent = markdownFile.GetText()?.ToString() ?? string.Empty;
            var documentationContent = GenerateDocumentation(mdContent, Path.GetFileNameWithoutExtension(sourceFile.FilePath));

            var documentationFileName = Path.GetFileNameWithoutExtension(sourceFile.FilePath) + ".Documentation.cs";

            context.AddSource
            (
                documentationFileName,
                SourceText.From(documentationContent, Encoding.UTF8)
            );
        });
    }

    private static string GenerateDocumentation(string markdownContent, string className)
    {
        var documentation = new StringBuilder();
        documentation.AppendLine("// <auto-generated/>");
        documentation.AppendLine("#nullable enable");
        documentation.AppendLine();
        
        // Extract namespace from class documentation if it exists, otherwise use default
        var namespaceMatch = Regex.Match(markdownContent, @"namespace\s+([\w.]+)");
        var namespaceName = namespaceMatch.Success ? 
            namespaceMatch.Groups[1].Value : 
            "TimeWarp.SourceGenerators.Documentation";
            
        documentation.AppendLine($"namespace {namespaceName};");
        documentation.AppendLine();

        // Split content into sections
        var sections = markdownContent.Split(new[] { "\r\n\r\n", "\n\n" }, StringSplitOptions.RemoveEmptyEntries);
        
        // Process class documentation
        var classSection = sections.First();
        documentation.AppendLine("/// <summary>");
        documentation.AppendLine($"/// {classSection.Split('\n').Last().Trim()}");
        documentation.AppendLine("/// </summary>");
        documentation.AppendLine($"public partial class {className}");
        documentation.AppendLine("{");

        // Process method documentation
        var methodSections = sections.Where(s => s.StartsWith("### ")).ToList();
        foreach (var methodSection in methodSections)
        {
            var lines = methodSection.Split('\n');
            var methodName = lines[0].TrimStart('#', ' ');
            
            documentation.AppendLine("    /// <summary>");
            
            // Add method description
            var descriptionLines = lines.Skip(1)
                .TakeWhile(l => !l.Trim().StartsWith("Parameters:") && !l.Trim().StartsWith("Returns:"))
                .Where(l => !string.IsNullOrWhiteSpace(l));
                
            foreach (var line in descriptionLines)
            {
                documentation.AppendLine($"    /// {line.Trim()}");
            }
            documentation.AppendLine("    /// </summary>");

            // Add parameters
            var parametersSection = lines.SkipWhile(l => !l.Trim().StartsWith("Parameters:"))
                .TakeWhile(l => !l.Trim().StartsWith("Returns:"))
                .Skip(1) // Skip "Parameters:" line
                .Where(l => !string.IsNullOrWhiteSpace(l));

            foreach (var param in parametersSection)
            {
                var paramMatch = Regex.Match(param.Trim(), @"-\s*(\w+):\s*(.+)");
                if (paramMatch.Success)
                {
                    documentation.AppendLine($"    /// <param name=\"{paramMatch.Groups[1].Value.Trim()}\">{paramMatch.Groups[2].Value.Trim()}</param>");
                }
            }

            // Add return value
            var returnsLine = lines.FirstOrDefault(l => l.Trim().StartsWith("Returns:"));
            if (returnsLine != null)
            {
                var returnDescription = returnsLine.Substring("Returns:".Length).Trim();
                documentation.AppendLine($"    /// <returns>{returnDescription}</returns>");
            }

            documentation.AppendLine();
        }

        documentation.AppendLine("}");

        return documentation.ToString();
    }
}
