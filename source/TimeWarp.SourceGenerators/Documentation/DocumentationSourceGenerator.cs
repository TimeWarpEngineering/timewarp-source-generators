namespace TimeWarp.SourceGenerators;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;

[Generator(LanguageNames.CSharp)]
public sealed class MarkdownDocsGenerator : IIncrementalGenerator
{
  // Define diagnostics descriptors as static fields for consistency
  private static readonly DiagnosticDescriptor FileFoundInfo = new(
    id: "MDGEN001",
    title: "Markdown documentation file found",
    messageFormat: "Documentation file found: {0}",
    category: "MarkdownDocumentation",
    DiagnosticSeverity.Info,
    isEnabledByDefault: true
  );

  private static readonly DiagnosticDescriptor ProcessingStarted = new(
    id: "MDGEN002",
    title: "Processing documentation file",
    messageFormat: "Processing documentation for: {0}",
    category: "MarkdownDocumentation",
    DiagnosticSeverity.Info,
    isEnabledByDefault: true
  );

  private static readonly DiagnosticDescriptor FileEmpty = new(
    id: "MDGEN003",
    title: "Documentation file is empty",
    messageFormat: "Documentation file is empty: {0}",
    category: "MarkdownDocumentation",
    DiagnosticSeverity.Warning,
    isEnabledByDefault: true
  );

  private static readonly DiagnosticDescriptor GenerationSuccess = new(
    id: "MDGEN004",
    title: "Documentation generated successfully",
    messageFormat: "Generated documentation for: {0}",
    category: "MarkdownDocumentation",
    DiagnosticSeverity.Info,
    isEnabledByDefault: true
  );

  private static readonly DiagnosticDescriptor GenerationError = new(
    id: "MDGEN005",
    title: "Documentation generation failed",
    messageFormat: "Failed to generate documentation for {0}: {1}",
    category: "MarkdownDocumentation",
    DiagnosticSeverity.Error,
    isEnabledByDefault: true
  );

  public void Initialize(IncrementalGeneratorInitializationContext context)
  {
    // Create a provider for finding markdown files
    IncrementalValuesProvider<AdditionalText> markdownFiles = context.AdditionalTextsProvider
      .Where(file => file.Path.EndsWith(".cs.md", StringComparison.OrdinalIgnoreCase));

    // Report found files
    context.RegisterSourceOutput(
      markdownFiles,
      (spc, file) => spc.ReportDiagnostic(
        Diagnostic.Create(FileFoundInfo, Location.None, Path.GetFileName(file.Path))
      )
    );

    // Process files
    IncrementalValuesProvider<(AdditionalText Left, Compilation Right)> csFiles = markdownFiles
      .Combine(context.CompilationProvider);

    // Register the source output
    context.RegisterSourceOutput(
      csFiles,
      (sourceProductionContext, pair) => Execute(sourceProductionContext, pair.Left, pair.Right));
  }

  private static void Execute(SourceProductionContext context, AdditionalText markdownFile, Compilation compilation)
  {
    string fileName = Path.GetFileName(markdownFile.Path);

    // Report starting to process
    context.ReportDiagnostic(
      Diagnostic.Create(ProcessingStarted, Location.None, fileName)
    );

    // Get the content of the markdown file
    SourceText? sourceText = markdownFile.GetText(context.CancellationToken);
    string markdownContent = sourceText?.ToString() ?? string.Empty;

    if (string.IsNullOrEmpty(markdownContent))
    {
      context.ReportDiagnostic(
        Diagnostic.Create(FileEmpty, Location.None, fileName)
      );
      return;
    }

    string csFilePath = markdownFile.Path.Substring(0, markdownFile.Path.Length - 3); // Remove .md from .cs.md
    string className = Path.GetFileNameWithoutExtension(csFilePath);

    try
    {
      string documentation = GenerateDocumentation(markdownContent);
      context.AddSource(
        $"{className}.Documentation.g.cs",
        SourceText.From(documentation, Encoding.UTF8)
      );

      context.ReportDiagnostic(
        Diagnostic.Create(GenerationSuccess, Location.None, fileName)
      );
    }
    catch (Exception ex)
    {
      context.ReportDiagnostic(
        Diagnostic.Create(GenerationError, Location.None, fileName, ex.Message)
      );
    }
  }

  private static string GenerateDocumentation(string markdown)
  {
    string[] lines = markdown.Split(new[] { '\n' }, StringSplitOptions.None);
    var docs = new StringBuilder();
    string currentSection = string.Empty;
    bool inCodeBlock = false;
    var codeBlockContent = new StringBuilder();

    docs.AppendLine("// <auto-generated/>");
    docs.AppendLine("// Generated by TimeWarp.SourceGenerators.MarkdownDocsGenerator");
    docs.AppendLine();
    docs.AppendLine("namespace TimeWarp.SourceGenerators;");
    docs.AppendLine();

    foreach (string line in lines)
    {
      string trimmedLine = line.Trim();

      // Handle code blocks
      if (trimmedLine.StartsWith("```", StringComparison.Ordinal))
      {
        if (inCodeBlock)
        {
          // End of code block - add the content
          docs.AppendLine("/// <code>");
          foreach (string codeLine in codeBlockContent.ToString().Split(new[] { '\n' }, StringSplitOptions.None))
          {
            docs.AppendLine($"/// {codeLine.TrimEnd()}");
          }
          docs.AppendLine("/// </code>");
          codeBlockContent.Clear();
        }
        inCodeBlock = !inCodeBlock;
        continue;
      }

      if (inCodeBlock)
      {
        codeBlockContent.AppendLine(trimmedLine);
        continue;
      }

      // Skip empty lines outside code blocks
      if (string.IsNullOrWhiteSpace(trimmedLine))
        continue;

      // Handle headers as section markers
      if (trimmedLine.StartsWith("#", StringComparison.Ordinal))
      {
        if (currentSection != string.Empty)
        {
          // Close previous section if exists
          docs.AppendLine($"/// </{currentSection}>");
        }
        currentSection = ParseHeaderToXmlTag(trimmedLine);
        docs.AppendLine($"/// <{currentSection}>");
        continue;
      }

      // Convert markdown line to XML doc comment
      string xmlLine = ConvertMarkdownToXml(trimmedLine);
      docs.AppendLine($"/// {xmlLine}");
    }

    // Close the last section if needed
    if (currentSection != string.Empty)
    {
      docs.AppendLine($"/// </{currentSection}>");
    }

    return docs.ToString();
  }

  private static string ParseHeaderToXmlTag(string header)
  {
    int level = header.TakeWhile(c => c == '#').Count();
    string text = header.Substring(level).Trim().ToLowerInvariant();

    return text switch
    {
      "summary" => "summary",
      "parameters" => "param",
      "returns" => "returns",
      "remarks" => "remarks",
      "examples" => "example",
      "exceptions" => "exception",
      "see also" => "seealso",
      _ => "remarks"
    };
  }

  private static string ConvertMarkdownToXml(string markdown)
  {
    string xml = markdown;

    // Handle markdown links
    xml = System.Text.RegularExpressions.Regex.Replace(
      xml,
      @"\[([^\]]+)\]\(([^\)]+)\)",
      "<see href=\"$2\">$1</see>"
    );

    // Handle inline code
    xml = System.Text.RegularExpressions.Regex.Replace(
      xml,
      @"`([^`]+)`",
      "<c>$1</c>"
    );

    // Handle parameters
    if (xml.IndexOf(':') != -1)
    {
      string[] parts = xml.Split(new[] { ':' }, 2, StringSplitOptions.None);
      if (parts.Length == 2)
      {
        return $"<param name=\"{parts[0].Trim()}\">{parts[1].Trim()}</param>";
      }
    }

    return xml;
  }
}
